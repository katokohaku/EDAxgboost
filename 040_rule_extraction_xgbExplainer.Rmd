---
author: "Satoshi Kato"
title: "rule extraction from xgboost model"
date: "`r format(Sys.time(), '%Y/%m/%d')`"
output:
  html_document:
    fig_caption: yes
    pandoc_args:
      - --from
      - markdown+autolink_bare_uris+tex_math_single_backslash-implicit_figures
    keep_md: yes
    toc: yes
  word_document:
    toc: yes
    toc_depth: 3
  pdf_document:
    toc: yes
    toc_depth: 3
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_knit$set(progress = TRUE, 
                     verbose  = TRUE, 
                     root.dir = ".")

knitr::opts_chunk$set(collapse = FALSE, 
                      comment = "", 
                      message = TRUE, 
                      warning = FALSE, 
                      include = TRUE,
                      echo    = TRUE)

set.seed(1)
```

```{r install.requirements, eval = FALSE}
install.packages("devtools", dependencies = TRUE)
devtools::install_github("AppliedDataSciencePartners/xgboostExplainer")

```

```{r require.packages, message=FALSE}
require(tidyverse)
require(magrittr)
require(data.table)
require(xgboost)
library(xgboostExplainer)

```

# Preparation (continued)

```{r}
kable_left <- function(df) {
  kable.df <- df %>% 
    knitr::kable(align=rep('l', 5)) %>%
    kableExtra::kable_styling(
      bootstrap_options = "striped",
      full_width = FALSE, 
      position   = "left")
  
  return(kable.df)
}

```

```{r load.model.and.data}
loaded.obs  <- readRDS("./middle/data_and_model.Rds")

model.xgb   <- loaded.obs$model$xgb 

train.label <- loaded.obs$data$train$label
train.matrix <- loaded.obs$data$train$matrix
train.xgb.DMatrix <- xgb.DMatrix("./middle/train.xgbDMatrix")

test.label  <- loaded.obs$data$test$label
test.matrix <- loaded.obs$data$test$matrix
test.xgb.DMatrix  <- xgb.DMatrix("./middle/test.xgbDMatrix")

```

# Preditive result of All

In this case, eval_metrics were high enough, therefore, we use test data for following evaluation

```{r}
test.pred <- predict(model.xgb, test.xgb.DMatrix)

prediction.counts <- table(test.pred, test.label) %>% 
  data.frame %>%
  mutate(
    predict = substr(test.pred, start = 1, stop = 4),
    count   = ifelse(test.label == "0", Freq, -Freq)) 

prediction.counts %>% 
  ggplot(aes(x =  reorder(predict, -as.numeric(predict)),
             y = count, 
             fill = test.label)) +
  geom_bar(stat="identity") +
  coord_flip() +
  labs(x = "prediction") +
  ggtitle(sprintf("%i rules of %i instance was extracted", 
                  NROW(prediction.counts), NROW(test.pred)))

```

# Feature pruning

Target features are filterd using `xgb.importance()`

```{r explainer.DALEX}
var.imp <- xgb.importance(model = model.xgb,
                          feature_names = dimnames(train.xgb.DMatrix)[[2]])

var.imp %>% mutate_if(is.numeric, round, digits = 4)
target.feature <- var.imp$Feature %>% head(5)
target.feature

train.selected <- loaded.obs$data$train$dummy.data.frame %>% 
  select(target.feature)
  
train.selected.xgb.DMatrix <- xgb.DMatrix(data  = as.matrix(train.selected),
                                          label = train.label)

test.selected <- loaded.obs$data$test$dummy.data.frame %>% 
  select(target.feature) 
test.selected.xgb.DMatrix <- xgb.DMatrix(data  = as.matrix(test.selected),
                                         label = test.label)
param.set <- loaded.obs$model$param.set
param.set$alpha <- 0.8
set.seed(1)
cv <- xgb.cv(params  = param.set, 
             verbose = 1,
             data    = train.selected.xgb.DMatrix,
             nrounds = 200,
             nfold   = 5,
             early_stopping_rounds = 5)

cv$evaluation_log %>% 
  select(-ends_with("_std")) %>% 
  tidyr::gather(key = data, value = auc, train_auc_mean, test_auc_mean) %>%
  ggplot(aes(x = iter, y = auc, color = as.factor(data))) +
  geom_line() +
  geom_vline(xintercept = cv$niter)


```

```{r}
model.selected.xgb <- xgb.train(params  = loaded.obs$model$param.set, 
                       verbose = 1,
                       data    = train.selected.xgb.DMatrix,
                       nrounds = cv$niter)

model.selected.xgb
```

```{r}
pred <- predict(model.selected.xgb, test.selected.xgb.DMatrix)
# length(pred)
prediction.counts <- table(pred, test.label) %>% 
  data.frame %>% 
  mutate(
      predict = substr(pred, start = 1, stop = 4) %>% as.numeric(),
    count   = ifelse(test.label == "0", Freq, -Freq)) %>% 
  filter(Freq >0 )

prediction.counts %>% 
  ggplot(aes(x = reorder(predict, -as.numeric(predict)),
             y = count, 
             fill = test.label)) +
  geom_bar(stat="identity") +
  coord_flip() +
  labs(x = "prediction") +
  ggtitle(sprintf("%i rules of %i instance was extracted", 
                  NROW(prediction.counts), NROW(test.pred)))

```

```{r, results="hide", message=FALSE}
explainer.xgb <-  buildExplainer(xgb.model    = model.selected.xgb, 
                                 trainingData = test.selected.xgb.DMatrix, 
                                 type         = "binary",
                                 base_score   = 0.5,
                                 trees_idx    = NULL)

```

```{r, results="hide", message=FALSE}
# install.packages("ggforce", dependencies = TRUE)
require(ggforce) # for `geom_sina`

xgb.breakdown <- explainPredictions(xgb.model = model.selected.xgb,
                                    explainer = explainer.xgb,
                                    data      = test.selected.xgb.DMatrix)
xgb.breakdown.loger <- xgb.breakdown %>%
  select(-intercept) %>% 
  mutate(id = 1:n()) %>% 
  gather(key = feature, value = impact, -id) %>% 
  arrange(id)

scaled.value.loger <- test.selected %>%
  scale() %>% 
  data.frame() %>% 
  mutate(id = 1:n()) %>% 
  gather(key = feature, value = value, -id) %>% 
  arrange(id)

feature.impact <- left_join(xgb.breakdown.loger,
                            scaled.value.loger,
                            by = c("id", "feature"))

ggplot(data = feature.impact) +
    coord_flip() + 
    # sina plot: 
    geom_sina(aes(x = feature, y = impact, color = value),
              method = "density", maxwidth = 1, alpha = 0.2) +
   scale_color_gradient(low="#FF0000", high="#0000FF", 
                        breaks=c(0,1), labels=c("Low        ","           High"),
                        guide = guide_colorbar(barwidth = 10, barheight = 0.3)) +
    theme_bw() + 
    theme(axis.line.y = element_blank(), 
          axis.ticks.y = element_blank(), # remove axis line
          legend.position="bottom",
          legend.title=element_text(size=10), 
          legend.text=element_text(size=8),
          axis.title.x= element_text(size = 10)) + 
    geom_hline(yintercept = 0) + # the vertical line
      labs(y = "feature attribution on model output", x = "", color = "Feature value  ") 
  
  
```

# clustering for extracted rules

```{r fig.height=6, fig.width=6}
# install.packages("Rtsne", dependencies = TRUE)
require(Rtsne)

# install.packages("plotly", dependencies = TRUE)
require(plotly)
set.seed(1)

feature.breakdown <- cbind(predict = test.pred, 
                           true    = test.label,
                           xgb.breakdown) %>%
  select(-intercept) %>% 
  # sample_n(1000) %>% 
  as.matrix()

rules.tsne <- Rtsne(feature.breakdown[, -(1:2)], perplexity = 100, check_duplicates = FALSE)
rules.tsne %>% str

mapping.tsne <-  data.frame(id      = 1:length(feature.breakdown[, 1]),
                            tsne1   = rules.tsne$Y[, 1],
                            tsne2   = rules.tsne$Y[, 2], 
                            predict = feature.breakdown[, 1],
                            true    = feature.breakdown[, 2])

ggp.map.tsne <- mapping.tsne %>% 
  ggplot(aes(x = tsne1, y = tsne2, color = predict, text = paste(id,true,sep=":"))) +
  geom_point(alpha = 0.5) + 
  scale_color_gradient(high="#FF0000", low="#0000FF") +  theme_bw()

plotly::ggplotly(ggp.map.tsne)

```


```{r, message=FALSE, results="hide"}
obs <- c(9135, 9993, 10000, 9999, 9890)

for(i in 1:length(obs)){
  
  ggp.sw <- showWaterfall(
    idx = obs[i],
    xgb.model   = model.selected.xgb, 
    explainer   = explainer.xgb, 
    DMatrix     = test.selected.xgb.DMatrix, 
    data.matrix = as.matrix(test.selected)) +
    ggtitle(paste("ID =", obs[i]))

  ggsave(ggp.sw, filename = sprintf("./output/image.files/040_explain_%05i.png", obs[i]))
}

```
![explain prediction](./output/image.files/040_explain_09135.png)
![explain prediction](./output/image.files/040_explain_09890.png)
![explain prediction](./output/image.files/040_explain_09993.png)
![explain prediction](./output/image.files/040_explain_09999.png)
![explain prediction](./output/image.files/040_explain_10000.png)
